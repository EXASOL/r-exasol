#' Create an R function as an UDF script on the EXASolution database
#' to prepare the parallel execution.
#'
#' This function takes an R function and creates a R UDF script on the
#' EXASolution database. A \code{CREATE SCRIPT} call will be used behind the
#' scenes. The return value is a function that, when executed, will execute the
#' script on the database server.
#'
#' We recommend to read the EXASolution manual about UDF scripts for a better
#' understanding.
#'
#' @param channel The RODBC connection channel, typically created via
#'   odbcConnect.
#' @param name The script will be created in the database with this name.
#' @param func The R function to be created as a UDF R script in the database.
#' @param env A list of values which will be available in the UDF function under
#'   the same name.
#'
#'   For example if you pass \code{list(a=2)} for this argument, you can access
#'   the value a in the function via \code{env$a}.
#'
#' @param initCode This code block will be executed once on each parallel
#'   instance of the database running the script, before the first call of the
#'   function.
#'
#' @param cleanCode This code block will be executed once on each parallel
#'   instance of the database running the script, after the function was called
#'   the last time.
#'
#' @param inType The input type of the UDF script, either \code{SET} or
#'   \code{SCALAR}.
#'
#' \code{SET} will call the function once for each group,
#' \code{SCALAR} will call the function once for each record.
#' Please read the EXASolution manual about UDF scripts for details.
#'
#' @param outType The output type of the UDF script, either \code{EMITS} or
#'   \code{RETURNS}. For \code{EMITS}, the function emits any number of values.
#'   For \code{RETURNS}, the function emits just a single value.
#'
#' @param inArgs Vector of strings specifying the names and types of the input
#'   arguments for the UDF script.
#'   Example: \code{inArgs = c("k INT", "v VARCHAR(10)")}
#'
#' @param outArgs Vector of strings specifying the names and types of the output
#'   arguments of the UDF script.
#'   Example: \code{inArgs = c("outputstring VARCHAR(10)")}
#'
#' @param outputAddress This parameters specifies the address and port of the
#'   optional python output service is listening on. For example:
#'   \code{c("192.168.1.10", 3000)}.Please read the README.txt of this R package
#'   for details.
#'
#' @param replaceIfExists Boolean whether the script shall be replaced if it
#'   already exists. Either \code{TRUE} or \code{FALSE}.
#'
#' @return This function returns a function that, when called, will execute the
#'   script on the server. With the call you have to specify to which data it
#'   shall be applied. The returned function generates and executes a
#'   \code{SELECT SQL} statement behind the scenes. It has the following
#'   signature:
#'
#'   \code{function(..., table = NA, where = NA, groupBy = NA, restQuery = "",
#'   returnSQL = FALSE, reader = NA, server = NA)}
#'
#'   \item{...}{The first string parameters define the SQL expressions that will
#'   be used as the input for the UDF script. Typically this is one or more
#'   column names as you see in the example below.}
#'
#'   \item{table}{A string with the table name to which the function shall be
#'   applied to. You can specify quoted names the following:
#'   table='myschema."MyQuotedTable"'}
#'
#'   \item{where}{A string with the where clause (SQL) to filter the records.}
#'
#'   \item{groupBy}{A string with the group-by clause (SQL) that will be used to
#'   group the. This is especially important for SET UDF scripts that will be
#'   called once for each group.}
#'
#'   \item{returnSQL}{Boolean value. For TRUE, the autogenerated SQL statement
#'   will be returned, but NOT executed.}
#'
#'   \item{restQuery}{A string with additional SQL code that will be appended at
#'   the end of the autogenerated query, e.g. ORDER BY or HAVING.}
#'
#'   \item{reader}{For internal usage only.}
#'
#'   \item{server}{For internal usage only.}
#'
#'   \item{RETURN VALUE}{The return value of the function is the result of the
#'   SELECT query. The query will be executed internally with the exa.readData
#'   function.}
#'
#' @author EXASOL AG <support@@exasol.com>
#'
#' @examples
#' # This example creates a simple SET-EMITS script and executes
#' # it the table footable.
#' require(RODBC)
#' require(exasol)
#'
#' # Connect via RODBC with configured DSN
#' C <- odbcConnect("exasolution")
#'
#' # Generate example data frame with two groups
#' # of random values with different means.
#' valsMean0  <- rnorm(10, 0)
#' valsMean50 <- rnorm(10, 50)
#' twogroups <- data.frame(group = rep(1:2, each = 10),
#'                         value = c(valsMean0, valsMean50))
#' # Write example data to a table
#' odbcQuery(C, "CREATE SCHEMA test")
#' odbcQuery(C, "CREATE TABLE test.twogroups (groupid INT, val DOUBLE)")
#' exa.writeData(C, twogroups, tableName = "test.twogroups")
#'
#' # Create the R function as an UDF R script in the database
#' # In our case it computes the mean for each group.
#' testscript <- exa.createScript(
#'   C,
#'   "test.mymean",
#'   function(data) {
#'     data$next_row(NA); # read all values from this group into a single vector
#'     data$emit(data$groupid[[1]], mean(data$val))
#'   },
#'   inArgs = c( "groupid INT", "val DOUBLE" ),
#'   outArgs = c( "groupid INT", "mean DOUBLE" ) )
#'
#' # Run the function, grouping by the groupid column
#' # and aggregating on the "val" column. This returns
#' # two values which are close to the means of the two groups.
#' testscript ("groupid", "val", table = "test.twogroups" , groupBy = "groupid")
#'
#' @export
exa.createScript <- function(channel, name, func = NA,
                             env = list(),
                             initCode = NA,
                             cleanCode = NA,
                             inType = SET,
                             inArgs = list(),
                             outType = EMITS,
                             outArgs = list(),
                             outputAddress = NA,
                             replaceIfExists = TRUE) {
  m <- match.call()
  code <- func
  initCode <- m$initCode
  cleanCode <- m$cleanCode

  inType <- ifelse(is.null(m$inType), quote(SET), m$inType)
  outType <- ifelse(is.null(m$outType), quote(EMITS), m$outType)

  #inArgs <- lapply(2:(length(m$inArgs)), function(x)
  #                 paste(deparse(m$inArgs[[x]][[2]]), deparse(m$inArgs[[x]][[1]])))
  inArgs <- do.call(paste, c(as.list(inArgs), sep = ", "))
  if (outType == quote(EMITS)) {
    if (is.null(m$outArgs)) {
      stop("No output arguments given")
    }
    #outArgs <- paste("(", do.call(paste, c(lapply(2:(length(m$outArgs)), function(x)
    #                                              paste(deparse(m$outArgs[[x]][[2]]), deparse(m$outArgs[[x]][[1]]))),
    #                                       sep = ", ")), ")")
    outArgs <- paste("(", do.call(paste, c(as.list(outArgs), sep = ", ")), ")", sep = "")
  } else {
    outType <- quote(RETURNS)
    outArgs <- as.character(outArgs)
  }
  #print(paste('###', inArgs))
  #print(paste('###', outArgs))

  sql <- paste("CREATE", if (replaceIfExists) "OR REPLACE" else "", "R",
               deparse(inType), "SCRIPT", name,
               "(", inArgs, ")",
               deparse(outType), outArgs, "AS")

  if (!is.null(m$outputAddress))
    sql <- paste(sql,
                 "# activate output to external server",
                 paste("output_connection__ <- socketConnection('", outputAddress[[1]], "', ", outputAddress[[2]], ")", sep = ''),
                 "sink(output_connection__)",
                 "sink(output_connection__, type = \"message\")",
                 "# ----------------------------------",
                 sep = "\n")
  if (!is.null(m$env)) {
    sql <- paste(sql, "\nenv <- ", do.call(paste, c(as.list(deparse(env)), sep = "\n")), "\n", sep = "")
  }
  if (!is.null(initCode)) {
    sql <- paste(sql, "\n# code from the init function")
    for (codeLine in deparse(initCode)) {
      sql <- paste(sql, codeLine, sep = "\n")
    }
    sql <- paste(sql, "\n# ---------------------------")
  }
  if (!is.null(cleanCode)) {
    sql <- paste(sql, "cleanup <- function()", sep = "\n")
    for(codeLine in deparse(cleanCode)) {
      sql <- paste(sql, codeLine, sep = "\n")
    }
  }
  sql <- paste(sql, "run <-", sep = "\n")
  for (codeLine in deparse(code)) {
    sql <- paste(sql, codeLine, sep = "\n")
  }
  sql <- paste(sql, "", sep = "\n")

  if (odbcQuery(channel, sql) == -1) {
    stop(odbcGetErrMsg(channel)[[1]])
  }

  function(..., table = NA, where = NA, groupBy = NA, restQuery = "",
           returnSQL = FALSE, reader = NA, server = NA) {
    m <- match.call(expand.dots = FALSE)
    args <- c(...)
    args <- lapply(1:(length(args)), function(x) as.character(args[[x]]))
    sql <- paste("SELECT * FROM (SELECT ",
                 name, "(", do.call(paste, c(args, sep = ", ")), ")",
                 " FROM ", table,
                 if (!is.null(m$where)) paste(" WHERE", as.character(where)),
                 if (!is.null(m$groupBy)) paste(" GROUP BY", as.character(groupBy)),
                 ")",
                 if (!is.null(m$restQuery)) paste("", as.character(restQuery)),
                 sep = "")
    if (returnSQL) {
      paste('(', sql, ')', sep = '')
    } else {
      execArgs <- list(channel, sql)
      if (!is.null(m$reader)) execArgs <- c(execArgs, reader = reader)
      if (!is.null(m$server)) execArgs <- c(execArgs, server = server)
      do.call(exa.readData, execArgs)
    }
  }
}
